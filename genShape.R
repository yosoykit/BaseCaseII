genShape <- function(xy = xy, nbr = nbr, size = 10, gamma = 1, col = 'blue') {

# xy: generated by genHexGrid (crypt coordinates x and y and dims nx and ny)
# nbr: generated by neighborList
# gamma: diffusness of shape: > 0 (compact) or < 0 (diffuse)
# tests
if(xy$ny %% 2 != 0) {
  warning("grid not set up correctly: ny required to be even")
  return()
}

# neighbor list ... with quasi-periodic bc
N = length(xy$x); nx = xy$nx; ny = xy$ny
nbr.state = as.list(N)

# state vector with zeros (initialized to empty)
state = prob = numeric(N) 
## everyone assumed to have 75 mm esophagus circumference

# simulate shape starting near center point
#istart = floor((N-nx)/2)

# simulate shop in random spot in biopsy quadrant
istart = sample(1:N,1,prob=rep(1/N,N))

state[istart] = 1; prob[istart]=0.5
nbr.state[[istart]] = state[nbr[[istart]]]

# only divide cells that have state 1 with prob
prob = prob * state   

# initialize shape generation
n = 2

set.1 = which(state==1)  #### do not need all state 1 (occupied), only surface is needed
prob.1 = prob[set.1]
j = sample(nbr[[istart]],size=1, prob=1-nbr.state[[istart]])  # only occupy empty slots

# update grid
state[j] = 1
nbr.state[[istart]] = state[nbr[[istart]]]
nbr.state[[j]] = state[nbr[[j]]]

prob[istart] = (max(c(0.1666667,sum(nbr.state[[istart]])))/6) 
prob[j] = (max(c(0.1666667,sum(nbr.state[[j]])))/6)^gamma
  
set.1 = which(state==1)
prob.1 = prob[set.1]
#points(xy$x[j],xy$y[j],pch=19,cex=0.6,col='blue')

# loop 
while (n < size) {
  if (length(set.1)==1){
    i=set.1
  }
  else{
    i = sample(set.1, size=1, prob=prob.1)
  }
  if (length(nbr[[i]])==1){
    j=nbr[[i]]
  }
  else{
    j = sample(nbr[[i]],size=1, prob=1-nbr.state[[i]])  # only occupy empty slots
  }
  # update affected grid points 
  state[j] = 1
  
  nbr.state[[i]] = state[nbr[[i]]]
  prob[i] = (max(c(0.1666667,sum(nbr.state[[i]])))/6)^gamma
  #print(prob[i])

  nbr.state[[j]] = state[nbr[[j]]]
  prob[j] = (max(c(0.1666667,sum(nbr.state[[j]])))/6)^gamma  ### fix problem with quasi-bc
  #print(prob[j])

  for(k in 1:6) {
   ik = nbr[[i]][k]
   if(state[ik] == 1) {
     nbr.state[[ik]] =  state[nbr[[ik]]]
     prob[ik] = (max(c(0.1666667,sum(nbr.state[[ik]])))/6)^gamma
     #print(prob[ik])
   }

   jk = nbr[[j]][k]
   if(state[jk] == 1) {
     nbr.state[[jk]] =  state[nbr[[jk]]]
     prob[jk] = (max(c(0.1666667,sum(nbr.state[[jk]])))/6)^gamma
     #print(prob[jk])
   }
  } 
  prob[prob==1] = 0     # once cells are fully surrounded  - exclude from further sampling
  if (length(which(prob>0))>0){
    set.1 = which(prob>0) # only select cells that have available neighboring slots 
  }
  else{n=size}

  prob.1 = prob[set.1]
  # points(xy$x[j],xy$y[j],pch=19,cex=0.6,col='blue')
  n = n + 1
}

#points(xy$x[set.1],xy$y[set.1],pch=19,cex=0.55,col=col) # plots active cells
points(xy$x[which(state==1)],xy$y[which(state==1)],pch=19,cex=0.5,col=col) # plots active cells
#points(xy$x[istart],xy$y[istart],pch=19,cex=0.6,col=1)
#rect(-3/2,-5/2,3/2,5/2, lwd = 1.5,lty=2)

return(list(xpremalig =xy$x[which(state==1)], ypremalig=xy$y[which(state==1)],state=state))
}

### PLOTS ALL CLONES 
genShape_all <- function(xy = xy, nbr = nbr, size = 10, gamma = 1, col = 'blue') {

# xy: generated by genHexGrid (crypt coordinates x and y and dims nx and ny)
# nbr: generated by neighborList
# gamma: diffusness of shape: > 0 (compact) or < 0 (diffuse)
# tests
if(xy$ny %% 2 != 0) {
  warning("grid not set up correctly: ny required to be even")
  return()
}

# neighbor list ... with quasi-periodic bc
N = length(xy$x); nx = xy$nx; ny = xy$ny
nbr.state = as.list(N)

# state vector with zeros (initialized to empty)
state = prob = numeric(N) 
## everyone assumed to have 75 mm esophagus circumference

# simulate shape starting near center point
#istart = floor((N-nx)/2)

# simulate shop in random spot in biopsy quadrant
istart = sample(1:N,1,prob=rep(1/N,N))

state[istart] = 1; prob[istart]=0.5
nbr.state[[istart]] = state[nbr[[istart]]]

# only divide cells that have state 1 with prob
prob = prob * state   

# initialize shape generation
n = 2

set.1 = which(state==1)  #### do not need all state 1 (occupied), only surface is needed
prob.1 = prob[set.1]
j = sample(nbr[[istart]],size=1, prob=1-nbr.state[[istart]])  # only occupy empty slots

# update grid
state[j] = 1
nbr.state[[istart]] = state[nbr[[istart]]]
nbr.state[[j]] = state[nbr[[j]]]

prob[istart] = (max(c(0.1666667,sum(nbr.state[[istart]])))/6) 
prob[j] = (max(c(0.1666667,sum(nbr.state[[j]])))/6)^gamma
  
set.1 = which(state==1)
prob.1 = prob[set.1]
#points(xy$x[j],xy$y[j],pch=19,cex=0.6,col='blue')

# loop 
while (n < size) {
  if (length(set.1)==1){
    i=set.1
  }
  else{
    i = sample(set.1, size=1, prob=prob.1)
  }
  if (length(nbr[[i]])==1){
    j=nbr[[i]]
  }
  else{
    j = sample(nbr[[i]],size=1, prob=1-nbr.state[[i]])  # only occupy empty slots
  }
  # update affected grid points 
  state[j] = 1
  
  nbr.state[[i]] = state[nbr[[i]]]
  prob[i] = (max(c(0.1666667,sum(nbr.state[[i]])))/6)^gamma
  #print(prob[i])

  nbr.state[[j]] = state[nbr[[j]]]
  prob[j] = (max(c(0.1666667,sum(nbr.state[[j]])))/6)^gamma  ### fix problem with quasi-bc
  #print(prob[j])

  for(k in 1:6) {
   ik = nbr[[i]][k]
   if(state[ik] == 1) {
     nbr.state[[ik]] =  state[nbr[[ik]]]
     prob[ik] = (max(c(0.1666667,sum(nbr.state[[ik]])))/6)^gamma
     #print(prob[ik])
   }

   jk = nbr[[j]][k]
   if(state[jk] == 1) {
     nbr.state[[jk]] =  state[nbr[[jk]]]
     prob[jk] = (max(c(0.1666667,sum(nbr.state[[jk]])))/6)^gamma
     #print(prob[jk])
   }
  } 
  prob[prob==1] = 0     # once cells are fully surrounded  - exclude from further sampling
  if (length(which(prob>0))>0){
    set.1 = which(prob>0) # only select cells that have available neighboring slots 
  }
  else{n=size}

  prob.1 = prob[set.1]
  # points(xy$x[j],xy$y[j],pch=19,cex=0.6,col='blue')
  n = n + 1
}

#points(xy$x[set.1],xy$y[set.1],pch=19,cex=0.55,col=col) # plots active cells
points(xy$x[which(state==1)],xy$y[which(state==1)],pch=19,cex=0.5,col=col) # plots active cells
#points(xy$x[istart],xy$y[istart],pch=19,cex=0.6,col=1)
#rect(-3/2,-5/2,3/2,5/2, lwd = 1.5,lty=2)
return(list(xpremalig =xy$x[which(state==1)], ypremalig=xy$y[which(state==1)],state=state))
}

